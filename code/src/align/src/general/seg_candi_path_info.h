// This file is a part of iMapSplice. Please refer to LICENSE.TXT for the LICENSE
#ifndef SEG_CANDI_PATH_INFO_H
#define SEG_CANDI_PATH_INFO_H

#include <stdlib.h>
#include <stdio.h>
#include "index_info.h"
#include "seg_info.h"

#define GAP_MATCH 0
#define GAP_INSERTION 1
#define GAP_DELETION 2
#define GAP_SPLICE 3
#define FixSpliceBuffer 20 
#define LengthOfSeqPerMismatchAllowed 10

using namespace std;

class Seg_Candi_Path_Info
{
private:
	// candiSegPath before extension
	int chrNameInt;
	vector< int > segLocInReadVec;
	vector< int > segLenVec;
	vector< int > segPosInChrVec;
	int chrMapPos;
	int chrMapPos_end;

	// fix gaps, generated by SegPathInfo.finalizeCandiPath()
	vector< vector<Jump_Code> > segGapJumpCodeVecVec;
	vector< vector<int> > segGapMismatchPosVecVec;
	vector< vector<char> > segGapMismatchCharVecVec;
	vector< bool > segGapFixedBoolVec;

	// extension on head results ....
	//vector<Jump_Code> extensionJumpCodeVec_head;
	vector<int> extensionMismatchPosVec_head;
	vector<char> extensionMismatchCharVec_head;
	int extensionLength_head;
	// extension on tail results ....
	//vector<Jump_Code> extensionJumpCodeVec_tail;
	vector<int> extensionMismatchPosVec_tail;
	vector<char> extensionMismatchCharVec_tail;
	int extensionLength_tail;
public:
	Seg_Candi_Path_Info()
	{
		extensionLength_head = 0;
		extensionLength_tail = 0;
	}

	string returnSegCandiPathInfoStr(Index_Info* indexInfo)
	{
		string tmpStr;
		string tmpChrNameStr = indexInfo->returnChrNameStr(chrNameInt);
		tmpStr = tmpChrNameStr + ": ";
		for(int tmp = 0; tmp < segLocInReadVec.size(); tmp++)
		{
			string tmpSegInfoStr = int_to_str(segLocInReadVec[tmp]) + "," 
				+ int_to_str(segLenVec[tmp]) + ","
				+ int_to_str(segPosInChrVec[tmp]) + "-";
			tmpStr += tmpSegInfoStr; 
		}
		return tmpStr;
	}

	bool initiateWithSegIndexPairVec(Seg_Info* segInfo,
		vector< pair<int,int> >& candiPathSegIndexVecInSegInfo,
		Index_Info* indexInfo)
	{	
		//cout << endl << "initiateWithSegIndexPairVec starts ......" << endl;
		int firstSegIndex_group = candiPathSegIndexVecInSegInfo[0].first;
		int firstSegindex_candi = candiPathSegIndexVecInSegInfo[0].second;
		//cout << "firstSegIndex_group: " << firstSegIndex_group << endl;
		//cout << "firstSegindex_candi: " << firstSegindex_candi << endl;
		unsigned int firstSegMapPosInWholeGenome = segInfo->returnSegmentMapPos(
			firstSegIndex_group, firstSegindex_candi);
		//cout << "firstSegMapPosInWholeGenome: " << firstSegMapPosInWholeGenome << endl;
		int firstSegMapPos_chrNameInt = indexInfo->getChr(firstSegMapPosInWholeGenome);
		//cout << "firstSegMapPos_chrNameInt: " << firstSegMapPos_chrNameInt << endl;
		int candiPathSegIndexVecInSegInfo_size = candiPathSegIndexVecInSegInfo.size();	
		//cout << "candiPathSegIndexVecInSegInfo_size: " << candiPathSegIndexVecInSegInfo_size << endl;
		if(candiPathSegIndexVecInSegInfo_size > 1)
		{	
			int lastSegIndex_group = candiPathSegIndexVecInSegInfo[candiPathSegIndexVecInSegInfo_size-1].first;
			int lastSegIndex_candi = candiPathSegIndexVecInSegInfo[candiPathSegIndexVecInSegInfo_size-1].second;
			//cout << "lastSegIndex_group: " << lastSegIndex_group << endl;
			//cout << "lastSegIndex_candi: " << lastSegIndex_candi << endl;
			unsigned int lastSegMapPosInWholeGenome = segInfo->returnSegmentMapPos(
				lastSegIndex_group, lastSegIndex_candi);
			//cout << "lastSegMapPosInWholeGenome: " << lastSegMapPosInWholeGenome << endl;
			// #ifdef CAL_TIME
			// getChrLocation_begin = clock();
			// #endif 
			int lastSegMapPos_chrNameInt = indexInfo->getChr(lastSegMapPosInWholeGenome);
			// #ifdef CAL_TIME
			// getChrLocation_end = clock();
			// getChrLocation_cost = getChrLocation_cost + getChrLocation_end - getChrLocation_begin;
			// #endif 
			//cout << "lastSegMapPos_chrNameInt: " << lastSegMapPos_chrNameInt << endl;
			if(firstSegMapPos_chrNameInt != lastSegMapPos_chrNameInt)
				return false;			
			if(candiPathSegIndexVecInSegInfo_size == 2)
			{
				chrNameInt = firstSegMapPos_chrNameInt;
				int tmpSegLocInRead_first = segInfo->returnSegLocInRead(firstSegIndex_group);
				int tmpSegLocInRead_last = segInfo->returnSegLocInRead(lastSegIndex_group);
				segLocInReadVec.push_back(tmpSegLocInRead_first);
				segLocInReadVec.push_back(tmpSegLocInRead_last);
				int tmpSegLen_first = segInfo->returnSegmentLength(firstSegIndex_group);
				int tmpSegLen_last = segInfo->returnSegmentLength(lastSegIndex_group);
				segLenVec.push_back(tmpSegLen_first);
				segLenVec.push_back(tmpSegLen_last);
				int tmpSegPosInChr_first = indexInfo->getChrLocation_withChrNameInt(
					firstSegMapPosInWholeGenome, chrNameInt);
				int tmpSegPosInChr_last = indexInfo->getChrLocation_withChrNameInt(
					lastSegMapPosInWholeGenome, chrNameInt);
				segPosInChrVec.push_back(tmpSegPosInChr_first);
				segPosInChrVec.push_back(tmpSegPosInChr_last);
				chrMapPos = tmpSegPosInChr_first;
				chrMapPos_end = tmpSegPosInChr_last + tmpSegLen_last - 1;
			}
			else
			{	
				chrNameInt = firstSegMapPos_chrNameInt;
				int tmpSegLocInRead_first = segInfo->returnSegLocInRead(firstSegIndex_group);
				segLocInReadVec.push_back(tmpSegLocInRead_first);			
				int tmpSegLen_first = segInfo->returnSegmentLength(firstSegIndex_group);			
				segLenVec.push_back(tmpSegLen_first);			
				int tmpSegPosInChr_first = indexInfo->getChrLocation_withChrNameInt(
					firstSegMapPosInWholeGenome, chrNameInt);
				segPosInChrVec.push_back(tmpSegPosInChr_first);						
				for(int tmp = 1; tmp < candiPathSegIndexVecInSegInfo_size-1; tmp++)
				{
					int tmpSegIndex_group = candiPathSegIndexVecInSegInfo[tmp].first;
					int tmpSegIndex_candi = candiPathSegIndexVecInSegInfo[tmp].second;
					int tmpSegLocInRead_tmpMid = segInfo->returnSegLocInRead(tmpSegIndex_group);
					segLocInReadVec.push_back(tmpSegLocInRead_tmpMid);
					int tmpSegLen_tmpMid = segInfo->returnSegmentLength(tmpSegIndex_group);
					segLenVec.push_back(tmpSegLen_tmpMid);
					unsigned int tmpSegPosInWholeGenome_tmpMid = segInfo->returnSegmentMapPos(
						tmpSegIndex_group, tmpSegIndex_candi);
					int tmpSegPosInChr_tmpMid = indexInfo->getChrLocation_withChrNameInt(
						tmpSegPosInWholeGenome_tmpMid, chrNameInt);
					segPosInChrVec.push_back(tmpSegPosInChr_tmpMid);
				}
				int tmpSegLocInRead_last = segInfo->returnSegLocInRead(lastSegIndex_group);
				segLocInReadVec.push_back(tmpSegLocInRead_last);
				int tmpSegLen_last = segInfo->returnSegmentLength(lastSegIndex_group);
				segLenVec.push_back(tmpSegLen_last);
				int tmpSegPosInChr_last = indexInfo->getChrLocation_withChrNameInt(
					lastSegMapPosInWholeGenome, chrNameInt);
				segPosInChrVec.push_back(tmpSegPosInChr_last);
				chrMapPos = tmpSegPosInChr_first;
				chrMapPos_end = tmpSegPosInChr_last + tmpSegLen_last - 1;				
			}
			return true;
		}
		else
		{
			chrNameInt = firstSegMapPos_chrNameInt;
			int tmpSegLocInRead = segInfo->returnSegLocInRead(firstSegIndex_group);
			segLocInReadVec.push_back(tmpSegLocInRead);
			int tmpSegLen = segInfo->returnSegmentLength(firstSegIndex_group);
			segLenVec.push_back(tmpSegLen);
			int tmpSegPosInChr = indexInfo->getChrLocation_withChrNameInt(
				firstSegMapPosInWholeGenome, chrNameInt);
			segPosInChrVec.push_back(tmpSegPosInChr);
			chrMapPos = tmpSegPosInChr;
			chrMapPos_end = tmpSegPosInChr + tmpSegLen - 1;
			return true;
		}
	}

	void copySubPathJumpCodeVec2TargetJumpCodeVec_withSoftClip(
		int startLocInRead, int endLocInRead, int readLength,
		int tmpSubPathSegIndex_1st, int tmpSubPathSegIndex_last,
		vector<Jump_Code>& targetJumpCodeVec,
		vector<int>& targetMismatchPosVec,
		vector<char>& targetMismatchCharVec)
	{
		int currentTargetJumpCodeVecSize = 0;
		string currentTargetJumpCodeVecLastElementType;
		// soft clipping head
		if(startLocInRead != 1)
		{
			int softClipLen_head = startLocInRead - 1;
			Jump_Code softClipJumpCode_head(softClipLen_head, "S");
			targetJumpCodeVec.push_back(softClipJumpCode_head);
			currentTargetJumpCodeVecLastElementType = "S";
			currentTargetJumpCodeVecSize ++;
		}
		// extension head
		if(extensionLength_head > 0)
		{
			Jump_Code extensionJumpCode_head(extensionLength_head, "M");
			targetJumpCodeVec.push_back(extensionJumpCode_head); 
			int extensionMismatchPosVecSize_head = extensionMismatchPosVec_head.size();
			for(int tmp = 0; tmp < extensionMismatchPosVecSize_head; tmp++)
			{
				targetMismatchPosVec.push_back(extensionMismatchPosVec_head[tmp]);
				targetMismatchCharVec.push_back(extensionMismatchCharVec_head[tmp]);
			}
			currentTargetJumpCodeVecLastElementType = "M";
			currentTargetJumpCodeVecSize ++;			
		}
		// first seg in subpath main part
		int firstSegLen = segLenVec[tmpSubPathSegIndex_1st];
		string firstSegJumpCodeType = "M";
		if(firstSegJumpCodeType == currentTargetJumpCodeVecLastElementType)
		{
			targetJumpCodeVec[currentTargetJumpCodeVecSize-1].len += firstSegLen;
		}
		else
		{
			Jump_Code firstSegJumpCode(firstSegLen, firstSegJumpCodeType);
			targetJumpCodeVec.push_back(firstSegJumpCode);
			currentTargetJumpCodeVecLastElementType = "M";
			currentTargetJumpCodeVecSize ++;
		}
		// others in subpath main part
		int tmpSubPathGapIndex_1st = tmpSubPathSegIndex_1st;
		int tmpSubPathGapIndex_last = tmpSubPathSegIndex_last - 1;
		for(int tmp = tmpSubPathGapIndex_1st; tmp <= tmpSubPathGapIndex_last;
			tmp++)
		{
			for(int tmp2 = 0; tmp2 < (segGapJumpCodeVecVec[tmp]).size(); tmp2++)
			{
				int tmpJumpCodeLen = ((segGapJumpCodeVecVec[tmp])[tmp2]).len;
				string tmpJumpCodeType = ((segGapJumpCodeVecVec[tmp])[tmp2]).type;
				if(tmpJumpCodeType == currentTargetJumpCodeVecLastElementType)
				{
					targetJumpCodeVec[currentTargetJumpCodeVecSize-1].len += tmpJumpCodeLen;
				}
				else
				{
					targetJumpCodeVec.push_back(((segGapJumpCodeVecVec[tmp])[tmp2]));
					currentTargetJumpCodeVecLastElementType = tmpJumpCodeType;
					currentTargetJumpCodeVecSize ++;
				}
			}
			for(int tmp2 = 0; tmp2 < (segGapMismatchPosVecVec[tmp]).size(); tmp2++)
			{
				targetMismatchPosVec.push_back((segGapMismatchPosVecVec[tmp])[tmp2]);
				targetMismatchCharVec.push_back((segGapMismatchCharVecVec[tmp])[tmp2]);
			}
		}
		// extension tail
		if(extensionLength_tail > 0)
		{
			Jump_Code extensionJumpCode_tail(extensionLength_tail, "M");
			targetJumpCodeVec.push_back(extensionJumpCode_tail); 
			int extensionMismatchPosVecSize_tail = extensionMismatchPosVec_tail.size();
			for(int tmp = 0; tmp < extensionMismatchPosVecSize_tail; tmp++)
			{
				targetMismatchPosVec.push_back(extensionMismatchPosVec_tail[tmp]);
				targetMismatchCharVec.push_back(extensionMismatchCharVec_tail[tmp]);
			}
			currentTargetJumpCodeVecLastElementType = "M";
			currentTargetJumpCodeVecSize ++;			
		}	
		// soft clip tail
		if(endLocInRead != readLength)
		{
			int softClipLen_tail = readLength - endLocInRead;
			Jump_Code softClipJumpCode_tail(softClipLen_tail, "S");
			targetJumpCodeVec.push_back(softClipJumpCode_tail);
			currentTargetJumpCodeVecLastElementType = "S";
			currentTargetJumpCodeVecSize ++;
		}
	}

	int returnExtensionLen_head()
	{
		return extensionLength_head;
	}

	int returnExtensionLen_tail()
	{
		return extensionLength_tail;
	}

	int returnSegLocInRead(int segIndex)
	{
		return segLocInReadVec[segIndex];
	}

	int returnSegLen(int segIndex)
	{
		return segLenVec[segIndex];
	}

	int returnSegPosInChr(int segIndex)
	{
		return segPosInChrVec[segIndex];
	}

	int returnChrNameInt()
	{
		return chrNameInt;
	}

	int returnChrMapPos()
	{
		return chrMapPos;
	}

	int returnChrMapPos_end()
	{
		return chrMapPos_end;
	}

	void selectBestSubPath(int& bestSubPathSegIndex_first, 
		int& bestSubpathSegIndex_last)
	{
		vector< int > falseGapIndexVec;
		for(int tmp = 0; tmp < segGapFixedBoolVec.size(); tmp++)
		{
			bool gapTrueOrFalseBool = segGapFixedBoolVec[tmp];
			if(!gapTrueOrFalseBool)
				falseGapIndexVec.push_back(tmp);
		}

		vector< pair<int,int> > stitchedSegIndexIntervalVec;
		int falseGapIndexVecSize = falseGapIndexVec.size();
		int segGapFixedBoolVecSize = segGapFixedBoolVec.size(); // lastSeg index
		if(falseGapIndexVecSize == 0)
		{
			stitchedSegIndexIntervalVec.push_back(
				pair<int,int>(0,segGapFixedBoolVecSize));
		}
		else if(falseGapIndexVecSize == 1)
		{
			int tmpSegIndexBeforeTheOnlyFalseGap = falseGapIndexVec[0];
			int tmpSegIndexAfterTheOnlyFalseGap = falseGapIndexVec[0]+1;
			stitchedSegIndexIntervalVec.push_back(
				pair<int,int>(0,tmpSegIndexBeforeTheOnlyFalseGap));
			stitchedSegIndexIntervalVec.push_back(
				pair<int,int>(tmpSegIndexAfterTheOnlyFalseGap,segGapFixedBoolVecSize));
		}
		else
		{
			int tmpSegIndexBeforeTheFirstFalseGap = falseGapIndexVec[0];
			stitchedSegIndexIntervalVec.push_back(
				pair<int,int>(0,tmpSegIndexBeforeTheFirstFalseGap));
			for(int tmp = 0; tmp <= falseGapIndexVecSize-2; tmp++)
			{
				int tmpSegIndex_first = falseGapIndexVec[tmp]+1;
				int tmpSegIndex_last = falseGapIndexVec[tmp+1];
				stitchedSegIndexIntervalVec.push_back(pair<int,int>(tmpSegIndex_first, tmpSegIndex_last));
			}
			int tmpSegIndexAfterTheLastFalseGap = falseGapIndexVec[falseGapIndexVecSize-1]+1;
			stitchedSegIndexIntervalVec.push_back(pair<int,int>(tmpSegIndexAfterTheLastFalseGap, segGapFixedBoolVecSize));
		}

		this->generateSubPathLen_selectLongest(stitchedSegIndexIntervalVec, bestSubPathSegIndex_first, bestSubpathSegIndex_last);
	}

	void generateSubPathLen_selectLongest(
		vector< pair<int,int> >& stitchedSegIndexIntervalVec,
		int& bestSubPathSegIndex_first, int& bestSubPathSegIndex_last)
	{
		int tmpLongestSubPathLen = 0;
		// generate subPathSegLen
		for(int tmp = 0; tmp < stitchedSegIndexIntervalVec.size(); tmp++)
		{
			int tmpSubPathSegIndex_1st = stitchedSegIndexIntervalVec[tmp].first;
			int tmpSubPathSegIndex_last = stitchedSegIndexIntervalVec[tmp].second;
			int tmpSubPath_startLocInRead = segLocInReadVec[tmpSubPathSegIndex_1st];
			int tmpSubPath_endLocInRead = segLocInReadVec[tmpSubPathSegIndex_last] 
				+ segLenVec[tmpSubPathSegIndex_last] - 1;
			int tmpSubPathLen = tmpSubPath_endLocInRead - tmpSubPath_startLocInRead + 1;
			if(tmpSubPathLen > tmpLongestSubPathLen)
			{
				bestSubPathSegIndex_first = tmpSubPathSegIndex_1st;
				bestSubPathSegIndex_last = tmpSubPathSegIndex_last;
			}
		}
	}

	void doExtensionOnBothDirections(const string& readSeqInProcess,
		Index_Info* indexInfo)
	// fix me, for fast testing new method, no extension for now
	{
		extensionLength_head = 0; 
		extensionLength_tail = 0;
	}

	void fixSegGap_candiPath(const string& readSeqInProcess, 
		Index_Info* indexInfo)
	{
		//cout << "fixSegGap_candiPath starts ......" << endl;
		int segSize = segLocInReadVec.size();
		//cout << "segSize: " << segSize << endl;
		for(int tmp = 0; tmp < segSize-1; tmp++)
		{
			vector<Jump_Code> tmpSegGapJumpCodeVec;
			vector<int> tmpSegGapMismatchPosVec;
			vector<char> tmpSegGapMismatchCharVec;
			bool tmpSegGapFixedBool = false;

			int tmpSegIndex_1 = tmp;
			int tmpSegIndex_2 = tmp+1;
			int tmpSegLocInRead_1 = segLocInReadVec[tmpSegIndex_1];
			int tmpSegLocInRead_2 = segLocInReadVec[tmpSegIndex_2];
			int tmpSegLen_1 = segLenVec[tmpSegIndex_1];
			int tmpSegLen_2 = segLenVec[tmpSegIndex_2];
			int tmpSegPosInChr_1 = segPosInChrVec[tmpSegIndex_1];
			int tmpSegPosInChr_2 = segPosInChrVec[tmpSegIndex_2];
			// cout << "tmpSegIndex_1: " << tmpSegIndex_1 << endl;
			// cout << "tmpSegIndex_2: " << tmpSegIndex_2 << endl;
			// cout << "tmpSegLocInRead_1: " << tmpSegLocInRead_1 << endl; 
			// cout << "tmpSegLocInRead_2: " << tmpSegLocInRead_2 << endl; 
			// cout << "tmpSegLen_1: " << tmpSegLen_1 << endl;
			// cout << "tmpSegLen_2: " << tmpSegLen_2 << endl;
			// cout << "tmpSegPosInChr_1: " << tmpSegPosInChr_1 << endl;
			// cout << "tmpSegPosInChr_2: " << tmpSegPosInChr_2 << endl; 
			tmpSegGapFixedBool = this->fixDoubleAnchorGap(
				tmpSegGapMismatchPosVec, tmpSegGapMismatchCharVec,
				tmpSegGapJumpCodeVec, //chrNameInt,
				tmpSegLocInRead_1, tmpSegLocInRead_2,
				tmpSegLen_1, tmpSegLen_2,
				tmpSegPosInChr_1, tmpSegPosInChr_2,
				indexInfo, readSeqInProcess);
			//cout << "tmpSegGapFixedBool: " << tmpSegGapFixedBool << endl;
 			segGapJumpCodeVecVec.push_back(tmpSegGapJumpCodeVec);
			segGapMismatchPosVecVec.push_back(tmpSegGapMismatchPosVec);
			segGapMismatchCharVecVec.push_back(tmpSegGapMismatchCharVec);
			segGapFixedBoolVec.push_back(tmpSegGapFixedBool);
		}
		//cout << "fixSegGap_candiPath ends ......" << endl;
	}

	int extendBack(int readLoc, int chrPos,
		const string& readSeqInProcess,
		Index_Info* indexInfo, int extendBackLengthMax)
	{
		int tmp = 1;
		for(tmp = 1; tmp < extendBackLengthMax; tmp++)
		{
			if(readSeqInProcess.at(readLoc-tmp-1) 
				!= indexInfo->returnOneBaseCharInGenome(chrNameInt, chrPos-tmp))
				return tmp-1;
		}
		return extendBackLengthMax;
	}

	bool fixDoubleAnchorGap(
		vector<int>& tmpGapMismatchPosVec, vector<char>& tmpGapMismatchCharVec, 
		vector<Jump_Code>& tmpGapJumpCodeVec,
		int segmentLocInRead_1, int segmentLocInRead_2,
		int segmentLength_1, int segmentLength_2,
		int segmentMapPos_1, int segmentMapPos_2,
		Index_Info* indexInfo, const string& readSeq_inProcess)
	{
		//cout << "fixDoubleAnchorGap starts ......" << endl;
		int tmpGapCase = this->returnSegGapCase(
			segmentLocInRead_1, segmentLocInRead_2,
			segmentMapPos_1, segmentMapPos_2);
		//cout << "tmpGapCase: " << tmpGapCase << endl;
		bool fixDoubleAnchor_bool = false;
		int extendBackNumMax = segmentLocInRead_2 - 1 
			- (segmentLocInRead_1 + segmentLength_1) + 1;
		if(extendBackNumMax > segmentMapPos_2 - 1)
		{
			extendBackNumMax = segmentMapPos_2 - 1; 
		}
		int extendBackNum = this->extendBack(segmentLocInRead_2, segmentMapPos_2,
			readSeq_inProcess, indexInfo, extendBackNumMax);
		
		segmentLocInRead_2 = segmentLocInRead_2 - extendBackNum;
		segmentLength_2 = segmentLength_2 + extendBackNum;
		segmentMapPos_2 = segmentMapPos_2 - extendBackNum;

		if(tmpGapCase == GAP_MATCH)
		{
			fixDoubleAnchor_bool = this->fixDoubleAnchorMatch(
				tmpGapMismatchPosVec, tmpGapMismatchCharVec, tmpGapJumpCodeVec, 
				chrNameInt, segmentLocInRead_1, segmentLocInRead_2, 
				segmentLength_1, segmentLength_2, segmentMapPos_1, segmentMapPos_2,
				indexInfo, readSeq_inProcess);
		}
		else if(tmpGapCase == GAP_INSERTION)
		{
			fixDoubleAnchor_bool = this->fixDoubleAnchorInsertion(
				tmpGapMismatchPosVec, tmpGapMismatchCharVec, tmpGapJumpCodeVec, 
				chrNameInt, segmentLocInRead_1, segmentLocInRead_2, 
				segmentLength_1, segmentLength_2, segmentMapPos_1, segmentMapPos_2,
				indexInfo, readSeq_inProcess);
		}
		else if(tmpGapCase == GAP_DELETION)
		{
			fixDoubleAnchor_bool = this->fixDoubleAnchorDeletion(
				tmpGapMismatchPosVec, tmpGapMismatchCharVec, tmpGapJumpCodeVec, 
				chrNameInt, segmentLocInRead_1, segmentLocInRead_2, 
				segmentLength_1, segmentLength_2, segmentMapPos_1, segmentMapPos_2,
				indexInfo, readSeq_inProcess);
		}
		else if(tmpGapCase == GAP_SPLICE)
		{
			fixDoubleAnchor_bool = this->fixDoubleAnchorSplice(
				tmpGapMismatchPosVec, tmpGapMismatchCharVec, tmpGapJumpCodeVec, 
				chrNameInt, segmentLocInRead_1, segmentLocInRead_2, 
				segmentLength_1, segmentLength_2, segmentMapPos_1, segmentMapPos_2,
				indexInfo, readSeq_inProcess);
		}
		else
		{
			cout << "error in tmpGapCase ..." << endl;
			exit(1);
		}
		return fixDoubleAnchor_bool;
	}

	int returnSegGapCase(int segmentLocInRead_1, int segmentLocInRead_2,
		int segmentMapPos_1, int segmentMapPos_2)
	{
		int tmpDistance = (segmentMapPos_2-segmentLocInRead_2)
			- (segmentMapPos_1-segmentLocInRead_1);
		if(tmpDistance == 0)
			return GAP_MATCH;
		else if(tmpDistance > 0)
		{
			if(tmpDistance >= MAX_DELETION_LENGTH)
				return GAP_SPLICE;
			else
				return GAP_DELETION;
		}
		else if(tmpDistance < 0)
		{
			int tmpDistance_positive = 0 - tmpDistance;
			if(tmpDistance_positive <= MAX_INSERTION_LENGTH)
				return GAP_INSERTION;
			else
				return -1;
		}
		else
		{
			return -1;
		}
	}

	bool fixDoubleAnchorSplice(
		vector<int>& tmpMismatchPosVec, vector<char>& tmpMismatchCharVec, 
		vector<Jump_Code>& tmpGapJumpCodeVec, 
		int chrInt, int segmentLocInRead_1, int segmentLocInRead_2, 
		int segmentLength_1, int segmentLength_2, int segmentMapPos_1, int segmentMapPos_2,
		Index_Info* indexInfo, const string& readSeq_inProcess)
	{
		//cout << "fixDoubleAnchorSplice starts ......" << endl;
		int tmpBuffer_left = FixSpliceBuffer;//+1;
		if(tmpBuffer_left > segmentLength_1 - 2) //anchor >= 2
		{
			tmpBuffer_left = segmentLength_1 - 2;
		}
		int tmpBuffer_right = FixSpliceBuffer;//+1;
		if(tmpBuffer_right > segmentLength_2 - 2)
		{
			tmpBuffer_right = segmentLength_2 - 2;
		}

		int subSeqLengthInProcess = segmentLocInRead_2 - 1 - (segmentLocInRead_1 + segmentLength_1) + 1 + tmpBuffer_left + tmpBuffer_right;
		int spliceJunctionLength = (segmentMapPos_2 - segmentLocInRead_2) - (segmentMapPos_1 - segmentLocInRead_1);
		//cout << "spliceJunctionLength: " << spliceJunctionLength << endl;
		//size_t prefix_length = 0;
		size_t max_double_splice_mismatch = (subSeqLengthInProcess)/LengthOfSeqPerMismatchAllowed + 1;

			FixDoubleAnchor_Splice_Info* fixSpliceInfo = new FixDoubleAnchor_Splice_Info();
			bool splice_fixed = fixSpliceInfo->detectBestSpliceSite_withoutAnnotation(
				segmentLocInRead_1 + segmentLength_1 - tmpBuffer_left, segmentLocInRead_2 + tmpBuffer_right - 1,
				segmentMapPos_1 + segmentLength_1 - tmpBuffer_left, segmentMapPos_2 + tmpBuffer_right - 1,
				readSeq_inProcess, indexInfo, chrInt, max_double_splice_mismatch);
			//cout << "splice_fixed: " << splice_fixed << endl;
				if(splice_fixed && fixSpliceInfo->fixSpliceResultConfident())//((fixSpliceInfo->returnBestSplice_canonicalOrNot()) || (fixSpliceInfo->returnBestSplice_mismatchNum() <= 2) ) )
				{
					int prefix_length = fixSpliceInfo->returnBestSplice_prefixMatchLength();
					int firstMatchLength = //segmentLength_1 
						- tmpBuffer_left + prefix_length;
					int secondMatchLength = segmentLength_2 - tmpBuffer_right + subSeqLengthInProcess - prefix_length;

					Jump_Code firstMatchJumpCode(firstMatchLength, "M");
					Jump_Code spliceJumpCode(spliceJunctionLength, "N");
					Jump_Code secondMatchJumpCode(secondMatchLength, "M"); 

					fixSpliceInfo->generateBestSpliceMismatchVec(subSeqLengthInProcess, (segmentLocInRead_1 + segmentLength_1 - tmpBuffer_left));
					fixSpliceInfo->copyMismatchPos2TargetVec(tmpMismatchPosVec);
					fixSpliceInfo->copyMismatchChar2TargetVec(tmpMismatchCharVec);
					tmpGapJumpCodeVec.push_back(firstMatchJumpCode);
					tmpGapJumpCodeVec.push_back(spliceJumpCode);	
					tmpGapJumpCodeVec.push_back(secondMatchJumpCode);
					delete fixSpliceInfo;
					return true;
				}
				else
				{
					//cout << "\nstart to try fixing complicated SJ ....\n" << endl;
					FixDoubleAnchor_Splice_Complicate_Info* fixComplicateSpliceInfo = new FixDoubleAnchor_Splice_Complicate_Info();
					bool complicate_splice_fixed = fixComplicateSpliceInfo->detectComplicateSplice_withoutAnnotation(
						segmentLocInRead_1 + segmentLength_1 - tmpBuffer_left, segmentLocInRead_2 + tmpBuffer_right - 1,
						segmentMapPos_1 + segmentLength_1 - tmpBuffer_left, segmentMapPos_2 + tmpBuffer_right - 1,
						readSeq_inProcess, indexInfo, chrInt, max_double_splice_mismatch);
					//cout << "finish fixing complicated SJ ....." << endl;	
					bool complicated_splice_fixed_better_bool = false;
					if(complicate_splice_fixed)
					{
						complicated_splice_fixed_better_bool = fixComplicateSpliceInfo->compared2SpliceInfo(splice_fixed,
							fixSpliceInfo);
					}
					else
					{}

					if(complicated_splice_fixed_better_bool)
					{
						int prefix_match_length = fixComplicateSpliceInfo->return_prefix_match_length_best();
						int first_jumpCode_length = fixComplicateSpliceInfo->return_first_jumpCode_length_best();
						string first_jumpCode_type = fixComplicateSpliceInfo->return_first_jumpCode_type_best();
						int mid_match_length = fixComplicateSpliceInfo->return_mid_match_length_best();
						int second_jumpCode_length = fixComplicateSpliceInfo->return_second_jumpCode_length_best();
						string second_jumpCode_type = fixComplicateSpliceInfo->return_second_jumpCode_type_best();
						int suffix_match_length = fixComplicateSpliceInfo->return_suffix_match_length_best();
						
						Jump_Code prefixMatchJumpCode(prefix_match_length - tmpBuffer_left, "M");
						Jump_Code firstJumpCode(first_jumpCode_length, first_jumpCode_type);
						Jump_Code midMatchJumpCode(mid_match_length, "M");
						Jump_Code secondJumpCode(second_jumpCode_length, second_jumpCode_type); 				
						Jump_Code suffixMatchJumpCode(suffix_match_length - tmpBuffer_right + segmentLength_2, "M");

						fixComplicateSpliceInfo->generateBestComplicateSJMismatchVec(
							segmentLocInRead_1 + segmentLength_1 - tmpBuffer_left, segmentLocInRead_2 + tmpBuffer_right - 1);
						fixComplicateSpliceInfo->copyMismatchPos2TargetVec(tmpMismatchPosVec);
						fixComplicateSpliceInfo->copyMismatchChar2TargetVec(tmpMismatchCharVec);
						tmpGapJumpCodeVec.push_back(prefixMatchJumpCode);	
						tmpGapJumpCodeVec.push_back(firstJumpCode);
						tmpGapJumpCodeVec.push_back(midMatchJumpCode);	
						tmpGapJumpCodeVec.push_back(secondJumpCode);	
						tmpGapJumpCodeVec.push_back(suffixMatchJumpCode);	

						delete fixSpliceInfo;
						delete fixComplicateSpliceInfo;
						return true;
					}
					else if(splice_fixed)
					{
						int prefix_length = fixSpliceInfo->returnBestSplice_prefixMatchLength();
						int firstMatchLength = //segmentLength_1 
							- tmpBuffer_left + prefix_length;
						int secondMatchLength = segmentLength_2 - tmpBuffer_right + subSeqLengthInProcess - prefix_length;

						Jump_Code firstMatchJumpCode(firstMatchLength, "M");
						Jump_Code spliceJumpCode(spliceJunctionLength, "N");
						Jump_Code secondMatchJumpCode(secondMatchLength, "M"); 
						fixSpliceInfo->generateBestSpliceMismatchVec(subSeqLengthInProcess, (segmentLocInRead_1 + segmentLength_1 - tmpBuffer_left));
						fixSpliceInfo->copyMismatchPos2TargetVec(tmpMismatchPosVec);
						fixSpliceInfo->copyMismatchChar2TargetVec(tmpMismatchCharVec);
						tmpGapJumpCodeVec.push_back(firstMatchJumpCode);
						tmpGapJumpCodeVec.push_back(spliceJumpCode);	
						tmpGapJumpCodeVec.push_back(secondMatchJumpCode);						
						
						delete fixSpliceInfo;
						delete fixComplicateSpliceInfo;
						return true;
					}
					else
					{
						delete fixSpliceInfo;
						delete fixComplicateSpliceInfo;
						return false;
						//fixGapVec[index_fixGapVec].first = false;
					}
					//delete fixComplicateSpliceInfo;
				}
		//return;
	}

	bool fixDoubleAnchorDeletion(
		vector<int>& tmpGapMismatchPosVec, vector<char>& tmpGapMismatchCharVec, 
		vector<Jump_Code>& tmpGapJumpCodeVec, 
		int chrInt, int segmentLocInRead_1, int segmentLocInRead_2, 
		int segmentLength_1, int segmentLength_2, int segmentMapPos_1, int segmentMapPos_2,
		Index_Info* indexInfo, const string& readSeq_inProcess)
	{
		int subSeqLengthInProcess = segmentLocInRead_2 - 1 - (segmentLocInRead_1 + segmentLength_1) + 1;
			//+ buffer_left + buffer_right;
		int deletionLength = (segmentMapPos_2 - segmentLocInRead_2) - (segmentMapPos_1 - segmentLocInRead_1);

		if(subSeqLengthInProcess < 2)
		{
			Jump_Code deletionJumpCode(deletionLength, "D");
			Jump_Code secondMatchJumpCode(segmentLength_2 + subSeqLengthInProcess, "M");

			//fixGapVec[index_fixGapVec].first = true;
			//(fixGapVec[index_fixGapVec].second).first = subSeqLengthInProcess;
			tmpGapJumpCodeVec.push_back(deletionJumpCode);
			tmpGapJumpCodeVec.push_back(secondMatchJumpCode);	

			for(int tmpBaseIndex = 0; tmpBaseIndex < subSeqLengthInProcess; tmpBaseIndex++)
			{
				int tmpMismatchPos = segmentLocInRead_1 + segmentLength_1 + tmpBaseIndex;
				char tmpMismatchChar = indexInfo->returnOneBaseCharInGenome(chrInt,
					segmentMapPos_2 - subSeqLengthInProcess + tmpBaseIndex);
				tmpGapMismatchPosVec.push_back(tmpMismatchPos);
				tmpGapMismatchCharVec.push_back(tmpMismatchChar);
			}
		}
		else
		{
			FixDoubleAnchor_Deletion_Info* delInfo = new FixDoubleAnchor_Deletion_Info();
			int tmp_toFix_deletion_read_start = segmentLocInRead_1 + segmentLength_1;
			int tmp_toFix_deletion_read_end = segmentLocInRead_2 - 1;
			//int subSeqLengthInProcess = tmp_toFix_deletion_read_end - tmp_toFix_deletion_read_start + 1;
			int tmp_toFix_deletion_chrom_start = segmentMapPos_1 + segmentLength_1;
			int tmp_toFix_deletion_chrom_end = segmentMapPos_2 - 1;
			int tmp_max_allowed_mismatchNum = subSeqLengthInProcess/LengthOfSeqPerMismatchAllowed + 1;
			bool deletion_fixed = delInfo->detectBestDeletion_lessMismatch(tmp_toFix_deletion_read_start, 
				tmp_toFix_deletion_read_end, tmp_toFix_deletion_chrom_start, tmp_toFix_deletion_chrom_end, 
				readSeq_inProcess, indexInfo, chrNameInt, tmp_max_allowed_mismatchNum);
			if(deletion_fixed)
			{
				int firstMatchLength = //segmentLength_1 + 
						//prefix_length;
						delInfo->return_best_deletion_prefix_match_length();
				int secondMatchLength = segmentLength_2 + subSeqLengthInProcess - firstMatchLength;
				int mismatch_bits = delInfo->return_best_deletion_mismatch();
				Jump_Code firstMatchJumpCode(firstMatchLength
					//- buffer_left
					, "M");
				Jump_Code deletionJumpCode(deletionLength, "D");
				Jump_Code secondMatchJumpCode(secondMatchLength
					//- buffer_right
					, "M");
				tmpGapJumpCodeVec.push_back(firstMatchJumpCode);
				tmpGapJumpCodeVec.push_back(deletionJumpCode);
				tmpGapJumpCodeVec.push_back(secondMatchJumpCode);

				delInfo->generateBestDeletionMismatchVec((segmentLocInRead_1 + segmentLength_1));
				delInfo->copyMismatchPos2TargetVec(tmpGapMismatchPosVec);
				delInfo->copyMismatchChar2TargetVec(tmpGapMismatchCharVec);
				delete delInfo;
				return true;
			}
			else
			{
				delete delInfo;
				return false;
			}
		}
	}

	bool fixDoubleAnchorInsertion(
		vector<int>& tmpGapMismatchPosVec, vector<char>& tmpGapMismatchCharVec, 
		vector<Jump_Code>& tmpGapJumpCodeVec, 
		int chrInt, int segmentLocInRead_1, int segmentLocInRead_2, 
		int segmentLength_1, int segmentLength_2, int segmentMapPos_1, int segmentMapPos_2,
		Index_Info* indexInfo, const string& readSeq_inProcess)
	{
		int subSeqLengthInProcess = segmentLocInRead_2 - 1 - (segmentLocInRead_1 + segmentLength_1) + 1;
		int insertionLength = (segmentMapPos_1 - segmentLocInRead_1) - (segmentMapPos_2 - segmentLocInRead_2);

		if(subSeqLengthInProcess <= insertionLength)
		{
			int secondMatchLength = segmentLength_2 + subSeqLengthInProcess - insertionLength;
			if(secondMatchLength > 0)
			{
				Jump_Code midInsertionJumpCode(insertionLength, "I");	
				Jump_Code secondMatchJumpCode(segmentLength_2 + subSeqLengthInProcess - insertionLength, "M");
				tmpGapJumpCodeVec.push_back(midInsertionJumpCode);
				tmpGapJumpCodeVec.push_back(secondMatchJumpCode);
				return true;
				// no mismatch pos or char generated 		
			}
			else
			{
				return false;
			}
		}	 
		else
		{
			FixDoubleAnchor_Insertion_Info* insInfo = new FixDoubleAnchor_Insertion_Info();
			int tmp_toFix_insertion_read_start = segmentLocInRead_1 + segmentLength_1;
			int tmp_toFix_insertion_read_end = segmentLocInRead_2 - 1;
			int tmp_toFix_insertion_chrom_start = segmentMapPos_1 + segmentLength_1;
			int tmp_toFix_insertion_chrom_end = segmentMapPos_2 - 1;
			int tmp_max_allowed_mismatchNum = (subSeqLengthInProcess)/LengthOfSeqPerMismatchAllowed + 1;  
			// how to set the max-mismatch parameter

			bool insertion_fixed = insInfo->detectBestInsertion_lessMismatch(
				tmp_toFix_insertion_read_start, tmp_toFix_insertion_read_end,
				tmp_toFix_insertion_chrom_start, tmp_toFix_insertion_chrom_end, readSeq_inProcess, indexInfo,
				chrInt, tmp_max_allowed_mismatchNum);
			if(insertion_fixed)
			{
				int firstMatchLength = insInfo->return_best_insertion_prefix_match_length();
				int secondMatchLength = segmentLength_2 + subSeqLengthInProcess - firstMatchLength - insertionLength;
				int mismatch_bits = insInfo->return_best_insertion_mismatch();
				if(secondMatchLength > 0)			
				{
					Jump_Code firstMatchJumpCode(firstMatchLength, "M");
					Jump_Code insertionJumpCode(insertionLength, "I");
					Jump_Code secondMatchJumpCode(secondMatchLength, "M");

					tmpGapJumpCodeVec.push_back(firstMatchJumpCode);
					tmpGapJumpCodeVec.push_back(insertionJumpCode);		
					tmpGapJumpCodeVec.push_back(secondMatchJumpCode);
					insInfo->generateBestInsertionMismatchVec((segmentLocInRead_1 + segmentLength_1));
					insInfo->copyMismatchPos2TargetVec(tmpGapMismatchPosVec);
					insInfo->copyMismatchChar2TargetVec(tmpGapMismatchCharVec);
					delete insInfo;
					return true;
				}
				else
				{
					delete insInfo;
					return false;
				}
			}
			else
			{
				delete insInfo;
				return false;
			}
		}
	}

	bool fixDoubleAnchorMatch(
		vector<int>& tmpGapMismatchPosVec, vector<char>& tmpGapMismatchCharVec, 
		vector<Jump_Code>& tmpGapJumpCodeVec, 
		int chrInt, int segmentLocInRead_1, int segmentLocInRead_2, 
		int segmentLength_1, int segmentLength_2, int segmentMapPos_1, int segmentMapPos_2,
		Index_Info* indexInfo, const string& readSeq_inProcess)
	{
		int subSeq_toProcess_len = segmentLocInRead_2 - 1 - (segmentLocInRead_1 + segmentLength_1) + 1;
		if(subSeq_toProcess_len < 2)
		{
			Jump_Code matchJumpCode(subSeq_toProcess_len + segmentLength_2, "M");
			tmpGapJumpCodeVec.push_back(matchJumpCode);
			for(int tmp = 0; tmp < subSeq_toProcess_len; tmp++)
			{
				tmpGapMismatchPosVec.push_back(segmentLocInRead_1 + segmentLength_1 + tmp);
				tmpGapMismatchCharVec.push_back(indexInfo->getCharInChromosome(chrNameInt, 
					segmentMapPos_1 + segmentLength_1 + tmp));
			}
			return true;
		}
		else
		{
			string readSubSeq_toProcess = readSeq_inProcess.substr(
				segmentLocInRead_1 + segmentLength_1 - 1, subSeq_toProcess_len); 
			string chromSubSeq_toProcess = indexInfo->returnChromStrSubstr(
				chrInt, segmentMapPos_1 + segmentLength_1, subSeq_toProcess_len);

			int max_mismatch = subSeq_toProcess_len / LengthOfSeqPerMismatchAllowed + 1;

			FixDoubleAnchor_Match_Info* fixMatchInfo = new FixDoubleAnchor_Match_Info();
			bool scoreStringBool = fixMatchInfo->fixMatch(readSubSeq_toProcess, chromSubSeq_toProcess,
				max_mismatch, segmentLocInRead_1 + segmentLength_1);
			if(scoreStringBool)
			{
				Jump_Code matchJumpCode(//segmentLength_1 + 
					subSeq_toProcess_len + segmentLength_2, "M");
				tmpGapJumpCodeVec.push_back(matchJumpCode);
				fixMatchInfo->copyMismatchPos2TargetVec(tmpGapMismatchPosVec);
				fixMatchInfo->copyMismatchChar2TargetVec(tmpGapMismatchCharVec);		
				delete fixMatchInfo;
				return true;
			}
			else
			{	
				delete fixMatchInfo;
				return false;
			}
		}
	}	

};



class Seg_Candi_Path_Vec_Info
{
private:
	vector<Seg_Candi_Path_Info*> segCandiPathVec_Nor1;
	vector<Seg_Candi_Path_Info*> segCandiPathVec_Rcm1;
	vector<Seg_Candi_Path_Info*> segCandiPathVec_Nor2;
	vector<Seg_Candi_Path_Info*> segCandiPathVec_Rcm2;

	int repeatRegion_index_Nor1;
	int repeatRegion_index_Rcm1;
	int repeatRegion_index_Nor2;
	int repeatRegion_index_Rcm2;
public:
	Seg_Candi_Path_Vec_Info()
	{
		repeatRegion_index_Nor1 = -1;
		repeatRegion_index_Rcm1 = -1;
		repeatRegion_index_Nor2 = -1;
		repeatRegion_index_Rcm2 = -1;		
	}

	int returnRepeatRegion_index_Nor1()
	{
		return repeatRegion_index_Nor1;
	}

	int returnRepeatRegion_index_Rcm1()
	{
		return repeatRegion_index_Rcm1;
	}

	int returnRepeatRegion_index_Nor2()
	{
		return repeatRegion_index_Nor2;
	}	

	int returnRepeatRegion_index_Rcm2()
	{
		return repeatRegion_index_Rcm2;
	}

	int returnCandiPathChrMapPos(int type, int index)
	{
		if(type == 1)
		{
			return (segCandiPathVec_Nor1[index])->returnChrMapPos();
		}
		else if(type == 2)
		{
			return (segCandiPathVec_Rcm1[index])->returnChrMapPos();
		}
		else if(type == 3)
		{
			return (segCandiPathVec_Nor2[index])->returnChrMapPos();
		}
		else if(type == 4)
		{
			return (segCandiPathVec_Rcm2[index])->returnChrMapPos();
		}
		else
		{
			
		}				
	}

	string returnCandiPathVecStr(Index_Info* indexInfo)
	{
		string tmpStr = "candiPathVecStr:\n";
		tmpStr += "Nor1:\n";
		for(int tmp = 0; tmp < segCandiPathVec_Nor1.size(); tmp++)
		{
			tmpStr += (segCandiPathVec_Nor1[tmp]->returnSegCandiPathInfoStr(indexInfo));
			tmpStr += "\n";
		}
		tmpStr += "Rcm1:\n";
		for(int tmp = 0; tmp < segCandiPathVec_Rcm1.size(); tmp++)
		{
			tmpStr += (segCandiPathVec_Rcm1[tmp]->returnSegCandiPathInfoStr(indexInfo));
			tmpStr += "\n";
		}
		tmpStr += "Nor2:\n";
		for(int tmp = 0; tmp < segCandiPathVec_Nor2.size(); tmp++)
		{
			tmpStr += (segCandiPathVec_Nor2[tmp]->returnSegCandiPathInfoStr(indexInfo));
			tmpStr += "\n";
		}
		tmpStr += "Rcm2:\n";
		for(int tmp = 0; tmp < segCandiPathVec_Rcm2.size(); tmp++)
		{
			tmpStr += (segCandiPathVec_Rcm2[tmp]->returnSegCandiPathInfoStr(indexInfo));
			tmpStr += "\n";
		}	
		return tmpStr;				
	}

	bool twoSegCandiPathCanBePaired_Nor1Rcm2( 
		int index_Nor, int index_Rcm, int& chrMapEndPos_Rcm)
	{
		//cout << "tmpSegCandiPathCanBePaired_Nor1Rcm2 starts.... " << endl; 
		int chrNameInt_Nor = segCandiPathVec_Nor1[index_Nor]->returnChrNameInt();
		int chrNameInt_Rcm = segCandiPathVec_Rcm2[index_Rcm]->returnChrNameInt();
		//cout << "chrNameInt_Nor: " << chrNameInt_Nor << endl;
		//cout << "chrNameInt_Rcm: " << chrNameInt_Rcm << endl;
		if(chrNameInt_Nor != chrNameInt_Rcm)
			return false;
		int chrMapPos_Nor = segCandiPathVec_Nor1[index_Nor]->returnChrMapPos();
		int chrMapPos_Rcm = segCandiPathVec_Rcm2[index_Rcm]->returnChrMapPos();
		int chrMapPos_end_Nor = segCandiPathVec_Nor1[index_Nor]->returnChrMapPos_end();
		int chrMapPos_end_Rcm = segCandiPathVec_Rcm2[index_Rcm]->returnChrMapPos_end();
		// cout << "chrMapPos_Nor: " << chrMapPos_Nor << endl;
		// cout << "chrMapPos_Rcm: " << chrMapPos_Rcm << endl;
		// cout << "chrMapPos_end_Nor: " << chrMapPos_end_Nor << endl;
		// cout << "chrMapPos_end_Rcm: " << chrMapPos_end_Rcm << endl;		
		if(chrMapPos_Nor >= chrMapPos_end_Rcm)
		{
			//cout << "false 1 " << endl;
			return false;
		}
		else if(chrMapPos_end_Nor + READ_ALIGN_AREA_LENGTH <= chrMapPos_Rcm)
		{
			//cout << "false 2 " << endl;
			return false;
		}
		else
		{
			chrMapEndPos_Rcm = chrMapPos_end_Rcm;
			return true;
		}
	}

	bool twoSegCandiPathCanBePaired_Nor2Rcm1( 
		int index_Nor, int index_Rcm, int& chrMapEndPos_Rcm)
	{
		int chrNameInt_Nor = segCandiPathVec_Nor2[index_Nor]->returnChrNameInt();
		int chrNameInt_Rcm = segCandiPathVec_Rcm1[index_Rcm]->returnChrNameInt();
		if(chrNameInt_Nor != chrNameInt_Rcm)
			return false;
		int chrMapPos_Nor = segCandiPathVec_Nor2[index_Nor]->returnChrMapPos();
		int chrNapPos_Rcm = segCandiPathVec_Rcm1[index_Rcm]->returnChrMapPos();
		int chrMapPos_end_Nor = segCandiPathVec_Nor2[index_Nor]->returnChrMapPos_end();
		int chrMapPos_end_Rcm = segCandiPathVec_Rcm1[index_Rcm]->returnChrMapPos_end();
		if(chrMapPos_Nor >= chrMapPos_end_Rcm)
		{
			return false;
		}
		else if(chrMapPos_end_Nor + READ_ALIGN_AREA_LENGTH <= chrNapPos_Rcm)
		{
			return false;
		}
		else
		{
			chrMapEndPos_Rcm = chrMapPos_end_Rcm;
			return true;
		}
	}

	int returnSegCandiPathInfoVecSize(int alignInfoType)
	{
		if(alignInfoType == 1)
		{
			return segCandiPathVec_Nor1.size();
		}
		else if(alignInfoType == 2)
		{
			return segCandiPathVec_Rcm1.size();
		}
		else if(alignInfoType == 3)
		{
			return segCandiPathVec_Nor2.size();
		}
		else
		{
			return segCandiPathVec_Rcm2.size();
		}
	}

	Seg_Candi_Path_Info* returnCandiPath(int index, int alignInfoType)
	{
		if(alignInfoType == 1)
		{
			return segCandiPathVec_Nor1[index];
		}
		else if(alignInfoType == 2)
		{
			return segCandiPathVec_Rcm1[index];
		}
		else if(alignInfoType == 3)
		{
			return segCandiPathVec_Nor2[index];
		}
		else if(alignInfoType == 4)
		{
			return segCandiPathVec_Rcm2[index];
		}
		else
		{}
	}

	void generateSegCandiPathVecFromFourTypeSegInfo(
		Seg_Info* segInfo_Nor1, Seg_Info* segInfo_Rcm1,
		Seg_Info* segInfo_Nor2, Seg_Info* segInfo_Rcm2, Index_Info* indexInfo)
	{
		#ifdef CAL_TIME		
		getSegCandiPathVec_begin = clock();
		#endif		

		vector< vector< pair<int,int> > > candiPathSegIndexVecVecInSegInfo_Nor1;
		if(segInfo_Nor1->returnRepeatRegion_index() >= 0)	
			repeatRegion_index_Nor1 = segInfo_Nor1->returnRepeatRegion_index();
		else
			this->generateSegCandiPathVecFromSingleTypeSegInfo(segInfo_Nor1,
				candiPathSegIndexVecVecInSegInfo_Nor1);
		// cout << "Nor1 segIndexPair ..." << endl;
		// for(int tmp = 0; tmp < candiPathSegIndexVecVecInSegInfo_Nor1.size(); tmp++)
		// {
		// 	cout << "tmpPath: " << tmp+1 << endl;
		// 	for(int tmp2 = 0; tmp2 < (candiPathSegIndexVecVecInSegInfo_Nor1[tmp]).size(); tmp2++)
		// 	{
		// 		cout << (candiPathSegIndexVecVecInSegInfo_Nor1[tmp])[tmp2].first << "," 
		// 			<< (candiPathSegIndexVecVecInSegInfo_Nor1[tmp])[tmp2].second << "-";
		// 	}
		// 	cout << endl;
		// }
		vector< vector< pair<int,int> > > candiPathSegIndexVecVecInSegInfo_Rcm1; 
		if(segInfo_Rcm1->returnRepeatRegion_index() >= 0)
			repeatRegion_index_Rcm1 = segInfo_Rcm1->returnRepeatRegion_index();
		else
			this->generateSegCandiPathVecFromSingleTypeSegInfo(segInfo_Rcm1,
				candiPathSegIndexVecVecInSegInfo_Rcm1);

		vector< vector< pair<int,int> > > candiPathSegIndexVecVecInSegInfo_Nor2;
		if(segInfo_Nor2->returnRepeatRegion_index() >= 0)
			repeatRegion_index_Nor2 = segInfo_Nor2->returnRepeatRegion_index();
		else
			this->generateSegCandiPathVecFromSingleTypeSegInfo(segInfo_Nor2,
				candiPathSegIndexVecVecInSegInfo_Nor2);
		vector< vector< pair<int,int> > > candiPathSegIndexVecVecInSegInfo_Rcm2;
		if(segInfo_Rcm2->returnRepeatRegion_index() >= 0)
			repeatRegion_index_Rcm2 = segInfo_Rcm2->returnRepeatRegion_index();
		else
			this->generateSegCandiPathVecFromSingleTypeSegInfo(segInfo_Rcm2,
				candiPathSegIndexVecVecInSegInfo_Rcm2);

		#ifdef CAL_TIME		
		getSegCandiPathVec_end = clock();
		getSegCandiPathVec_cost = getSegCandiPathVec_cost + getSegCandiPathVec_end - getSegCandiPathVec_begin;
		initiateSegCandiPathVec_begin = clock();
		#endif
		for(int tmpPath = 0; tmpPath < candiPathSegIndexVecVecInSegInfo_Nor1.size();
			tmpPath ++)
		{
			Seg_Candi_Path_Info* segCandiPathInfo = new Seg_Candi_Path_Info();
			bool initiateSegCandiPathInfoBool 
				= segCandiPathInfo->initiateWithSegIndexPairVec(segInfo_Nor1,
					(candiPathSegIndexVecVecInSegInfo_Nor1[tmpPath]), indexInfo);
			if(initiateSegCandiPathInfoBool)
				segCandiPathVec_Nor1.push_back(segCandiPathInfo);
			else
				delete segCandiPathInfo;
		}

		for(int tmpPath = 0; tmpPath < candiPathSegIndexVecVecInSegInfo_Rcm1.size();
			tmpPath ++)
		{
			Seg_Candi_Path_Info* segCandiPathInfo = new Seg_Candi_Path_Info();
			bool initiateSegCandiPathInfoBool 
				= segCandiPathInfo->initiateWithSegIndexPairVec(segInfo_Rcm1,
					(candiPathSegIndexVecVecInSegInfo_Rcm1[tmpPath]), indexInfo); 
			if(initiateSegCandiPathInfoBool)	
				segCandiPathVec_Rcm1.push_back(segCandiPathInfo);
			else
				delete segCandiPathInfo;
		}

		for(int tmpPath = 0; tmpPath < candiPathSegIndexVecVecInSegInfo_Nor2.size();
			tmpPath ++)
		{
			Seg_Candi_Path_Info* segCandiPathInfo = new Seg_Candi_Path_Info();
			bool initiateSegCandiPathInfoBool 
				= segCandiPathInfo->initiateWithSegIndexPairVec(segInfo_Nor2,
					(candiPathSegIndexVecVecInSegInfo_Nor2[tmpPath]), indexInfo); 
			if(initiateSegCandiPathInfoBool)	
				segCandiPathVec_Nor2.push_back(segCandiPathInfo);
			else
				delete segCandiPathInfo;
		}

		for(int tmpPath = 0; tmpPath < candiPathSegIndexVecVecInSegInfo_Rcm2.size();
			tmpPath ++)
		{
			Seg_Candi_Path_Info* segCandiPathInfo = new Seg_Candi_Path_Info();
			bool initiateSegCandiPathInfoBool 
				= segCandiPathInfo->initiateWithSegIndexPairVec(segInfo_Rcm2,
					(candiPathSegIndexVecVecInSegInfo_Rcm2[tmpPath]), indexInfo); 
			if(initiateSegCandiPathInfoBool)	
				segCandiPathVec_Rcm2.push_back(segCandiPathInfo);
			else
				delete segCandiPathInfo;
		}				
		#ifdef CAL_TIME		
		initiateSegCandiPathVec_end = clock();
		initiateSegCandiPathVec_cost = initiateSegCandiPathVec_cost + initiateSegCandiPathVec_end - initiateSegCandiPathVec_begin;
		#endif
	}

	void generateSegCandiPathVecFromSingleTypeSegInfo(Seg_Info* segInfo,
		vector< vector< pair<int,int> > >& candiPathSegIndexVecVecInSegInfo)
	{
		//cout << "start to generateSegCandiPathVecFromSingleTypeSegInfo ...... " << endl;
		vector< unsigned int > candiPathCurrentLastSegMapPosEnd;
		vector< int > candiPathCurrentLastSegInReadLocEnd;
		if(segInfo->returnRepeatRegion_index() >= 0)
			return;
		int firstLongSegNO = segInfo->getFirstLongSegNO();
		if(firstLongSegNO < 0)
			return;
		int firstLongSeg_inReadLocEnd = segInfo->returnSegLocInRead_end(firstLongSegNO);
		for(int tmpSegCandiLoc = 0; tmpSegCandiLoc < segInfo->returnSegmentAlignNum(firstLongSegNO);
			tmpSegCandiLoc ++)
		{
			vector< pair<int,int> > tmpCandiPathSegIndexPairVec;
			tmpCandiPathSegIndexPairVec.push_back(pair<int,int>(firstLongSegNO, tmpSegCandiLoc));
			candiPathSegIndexVecVecInSegInfo.push_back(tmpCandiPathSegIndexPairVec);
			unsigned int tmpCandiPathLastSegMapPosEnd 
				= segInfo->returnSegmentMapPos_end(firstLongSegNO, tmpSegCandiLoc);
			candiPathCurrentLastSegMapPosEnd.push_back(tmpCandiPathLastSegMapPosEnd);
			candiPathCurrentLastSegInReadLocEnd.push_back(firstLongSeg_inReadLocEnd);
		}
		for(int tmpSegNO = firstLongSegNO + 1; tmpSegNO < segInfo->returnSegmentNum(); tmpSegNO++)
		{
			int tmpSegCandiAlignNum = segInfo->returnSegmentAlignNum(tmpSegNO);
			if( ( tmpSegCandiAlignNum > CANDALILOC )||( tmpSegCandiAlignNum <= 0) )
				continue;
			this->addNewSegGroup2currentCandiPathVec(segInfo, tmpSegNO,
				candiPathSegIndexVecVecInSegInfo, 
				candiPathCurrentLastSegMapPosEnd,
				candiPathCurrentLastSegInReadLocEnd);
		}		
	}


	unsigned int returnUnsignedMinusVal(unsigned int a, unsigned int b)
	{
		if(a > b)
			return (a-b);
		else
			return (b-a);
	}

	bool notBackSpliceBool(unsigned tmpDistance, unsigned a, unsigned b)
	{
		if(a >= b)
			return true;
		else
		{
			if(tmpDistance <= MAX_INSERTION_LENGTH)
				return true;
			else
				return false;
		}
	}

	int addNewSeg2currentCandiPathVec(Seg_Info* segInfo, int tmpSegNO, int tmpSegCandiNO,
		vector<unsigned int>& candiPathCurrentLastSegMapPosEnd,
		vector<int>& candiPathCurrentLastSegInReadLocEnd)
	{
		int tmpSegLocInRead = segInfo->returnSegLocInRead(tmpSegNO); 
		unsigned int tmpSegChrMapPos = segInfo->returnSegmentMapPos(tmpSegNO, tmpSegCandiNO);
		int candiPathCurrentLastSegMapPosEnd_size = candiPathCurrentLastSegMapPosEnd.size();
		int closestPathIndex = -1;
		unsigned int closestPathDistance = MAX_SPLICE_LENGTH + 1;
		for(int tmp = 0; tmp < candiPathCurrentLastSegMapPosEnd_size; tmp++)
		{
			int tmpCandiPathCurrentLastSegInReadLocEnd = candiPathCurrentLastSegInReadLocEnd[tmp];
			unsigned int tmpRelativeDistanceInReadLoc 
				= (unsigned int)tmpSegLocInRead 
					- (unsigned int)tmpCandiPathCurrentLastSegInReadLocEnd;
			unsigned int tmpCandiPathCurrentLastSegMapPosEnd = candiPathCurrentLastSegMapPosEnd[tmp];
			unsigned int tmpDistance = this->returnUnsignedMinusVal(tmpSegChrMapPos-tmpRelativeDistanceInReadLoc, 
				tmpCandiPathCurrentLastSegMapPosEnd);
			if( (tmpDistance < closestPathDistance)&&(this->notBackSpliceBool(tmpDistance, 
				tmpSegChrMapPos-tmpRelativeDistanceInReadLoc,
				tmpCandiPathCurrentLastSegMapPosEnd)) )
			{
				closestPathDistance = tmpDistance;
				closestPathIndex = tmp;
			}
		}
		return closestPathIndex;
	}

	void addNewSegGroup2currentCandiPathVec(Seg_Info* segInfo, int tmpSegNO,
		vector< vector< pair<int,int> > >& candiPathSegIndexVecVecInSegInfo,
		vector< unsigned int >& candiPathCurrentLastSegMapPosEnd,
		vector< int >& candiPathCurrentLastSegInReadLocEnd)
	{
		//cout << "start to addNewSegGroup2currentCandiPathVec(" << endl;
		//cout << "tmpSegNO: " << tmpSegNO << endl;
		bool longSegBool = segInfo->checkSegLongOrNot(tmpSegNO);
		int candiPathVecSize = candiPathSegIndexVecVecInSegInfo.size();
		//cout << "longSegBool: " << longSegBool << endl;
		//cout << "candiPathVecSize: " << candiPathVecSize << endl;
		vector<int> candiPath2AddSegCandiIndexVec;
		vector<unsigned int> candiPath2AddSegCandiIndexVec_endMapPos;
		for(int tmp = 0; tmp < candiPathVecSize; tmp++)
		{
			candiPath2AddSegCandiIndexVec.push_back(-1);
			candiPath2AddSegCandiIndexVec_endMapPos.push_back(0);
		}
		int currentSegGroupInReadLocEnd = segInfo->returnSegLocInRead_end(tmpSegNO);
		int currentSegGroupCandiNum = segInfo->returnSegmentAlignNum(tmpSegNO);
		//cout << "currentSegGroupCandiNum: " << currentSegGroupCandiNum << endl;
		vector<int> addedPathIndexForEachSegCandiVec; // size == currentSegGroupCandiNum
		for(int tmpCandiNO = 0; tmpCandiNO < currentSegGroupCandiNum; tmpCandiNO++)
		{
			//cout << "tmpCandiNO: " << tmpCandiNO << endl;
			int addedPathIndex = this->addNewSeg2currentCandiPathVec(
				segInfo, tmpSegNO, tmpCandiNO, candiPathCurrentLastSegMapPosEnd,
				candiPathCurrentLastSegInReadLocEnd);
			//cout << "addedPathIndex: " << addedPathIndex << endl;
			addedPathIndexForEachSegCandiVec.push_back(addedPathIndex);
			if(addedPathIndex >= 0)
			{
				int tmpCandiPath2AddSegCandiIndexVec_element_value 
					= candiPath2AddSegCandiIndexVec[addedPathIndex];
				//cout << "tmpCandiPath2AddSegCandiIndexVec_element_value: " 
				//	<< tmpCandiPath2AddSegCandiIndexVec_element_value << endl;
				if(tmpCandiPath2AddSegCandiIndexVec_element_value < 0) //no existed added segCandi
				{	
					candiPath2AddSegCandiIndexVec[addedPathIndex] = tmpCandiNO;
					candiPath2AddSegCandiIndexVec_endMapPos[addedPathIndex]
						= segInfo->returnSegmentMapPos_end(tmpSegNO, tmpCandiNO);
				}
				else // already added segCandi exists
				{
					unsigned int tmpCandiPath2AddSegCandiIndexVec_endMapPos_element_value
						= segInfo->returnSegmentMapPos_end(tmpSegNO, tmpCandiNO);
					unsigned int tmpCandiPath_currentMapPosEnd 
						= candiPath2AddSegCandiIndexVec_endMapPos[addedPathIndex];
					if(tmpCandiPath2AddSegCandiIndexVec_endMapPos_element_value
						 < tmpCandiPath_currentMapPosEnd)
					{
						candiPath2AddSegCandiIndexVec[addedPathIndex] = tmpCandiNO;
						candiPath2AddSegCandiIndexVec_endMapPos[addedPathIndex]
							= tmpCandiPath2AddSegCandiIndexVec_endMapPos_element_value;
					}
					else
					{}
				}
			}
			else
			{}
		}
		// update old path
		for(int tmpPath = 0; tmpPath < candiPathVecSize; tmpPath++)
		{
			int tmpCandiPath2AddSegCandiIndex = candiPath2AddSegCandiIndexVec[tmpPath];
			if(tmpCandiPath2AddSegCandiIndex >= 0)
			{
				candiPathSegIndexVecVecInSegInfo[tmpPath].push_back(pair<int,int>(tmpSegNO,
					tmpCandiPath2AddSegCandiIndex));
				candiPathCurrentLastSegMapPosEnd[tmpPath] 
					= candiPath2AddSegCandiIndexVec_endMapPos[tmpPath];
				candiPathCurrentLastSegInReadLocEnd[tmpPath] = currentSegGroupInReadLocEnd;
			}
		}
		// add new path
		if(longSegBool)
		{
			for(int tmpCandiNO = 0; tmpCandiNO < currentSegGroupCandiNum; tmpCandiNO ++)
			{	
				if(addedPathIndexForEachSegCandiVec[tmpCandiNO] < 0)
				{	
					vector< pair<int,int> > tmpNewCandiPath;
					tmpNewCandiPath.push_back(pair<int,int>(tmpSegNO, tmpCandiNO));
					candiPathSegIndexVecVecInSegInfo.push_back(tmpNewCandiPath);
					unsigned int tmpNewSegCandiSegMapPos_end = segInfo->returnSegmentMapPos_end(
						tmpSegNO, tmpCandiNO);
					candiPathCurrentLastSegMapPosEnd.push_back(tmpNewSegCandiSegMapPos_end);
					candiPathCurrentLastSegInReadLocEnd.push_back(currentSegGroupInReadLocEnd);
				}
			}
		}
		// // vector < vector< segCandiIndex > > -- size == currentPathVecSize
		// vector< vector<int> > candiPath2AddSegCandiIndexVecVec; 
		// int currentCandiPathVecSize = candiPathSegIndexVecInSegInfo.size();
		// for(int tmp = 0; tmp < currentCandiPathVecSize; tmp++)
		// {
		// 	vector<int> tmpIntVec;
		// 	candiPath2AddSegCandiIndexVecVec.push_back(tmpIntVec);
		// }
		// // extend currentPath candidates
		// for(int tmp = 0; tmp < addedPathIndexForEachSegCandiVec.size(); tmp++)
		// {
		// 	int tmpAddedPathIndex = addedPathIndexForEachSegCandiVec[tmp];
		// 	if(tmpAddedPathIndex >= 0)
		// 	{
		// 		candiPath2AddSegCandiIndexVecVec[tmpAddedPathIndex].push_back(tmp);
		// 	}
		// }
		// // select the best new seg added 2 current path
		// for(int tmp = 0; tmp < )
		// {

		// }
		// // add new path
	}

	void memoryFree()
	{
		int segCandiPathVec_Nor1_size = segCandiPathVec_Nor1.size();
		int segCandiPathVec_Rcm1_size = segCandiPathVec_Rcm1.size();
		int segCandiPathVec_Nor2_size = segCandiPathVec_Nor2.size();
		int segCandiPathVec_Rcm2_size = segCandiPathVec_Rcm2.size();
		for(int tmp = 0; tmp < segCandiPathVec_Nor1_size; tmp++)
		{
			delete segCandiPathVec_Nor1[tmp];
		}
		for(int tmp = 0; tmp < segCandiPathVec_Rcm1_size; tmp++)
		{
			delete segCandiPathVec_Rcm1[tmp];
		}
		for(int tmp = 0; tmp < segCandiPathVec_Nor2_size; tmp++)
		{
			delete segCandiPathVec_Nor2[tmp];
		}
		for(int tmp = 0; tmp < segCandiPathVec_Rcm2_size; tmp++)
		{
			delete segCandiPathVec_Rcm2[tmp];
		}				
	}
};
#endif